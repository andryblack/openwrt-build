From f413a3a9f3d81da1b93c4e19f0f18d5ad26efb9a Mon Sep 17 00:00:00 2001
From: andryblack <blackicebox@gmail.com>
Date: Fri, 24 Apr 2020 00:16:31 +0300
Subject: [PATCH 2/4] linux: userspace GPIO control via libgpiod

Allow use host GPIO pins for non-realtime purposes.

Signed-off-by: Andrey Kunitsyn <blackicebox@gmail.com>
---
 src/linux/Kconfig    |   6 ++
 src/linux/Makefile   |   6 +-
 src/linux/analog.c   |   8 ++-
 src/linux/gpio.c     | 153 +++++++++++++++++++++++++++++++++++++++++++
 src/linux/gpio.h     |  26 ++++++--
 src/linux/hard_pwm.c |   2 +-
 src/linux/spidev.c   |  12 ----
 7 files changed, 190 insertions(+), 23 deletions(-)
 create mode 100644 src/linux/gpio.c

diff --git a/src/linux/Kconfig b/src/linux/Kconfig
index 53fb22fe..2eee7d4f 100644
--- a/src/linux/Kconfig
+++ b/src/linux/Kconfig
@@ -11,6 +11,12 @@ config LINUX_SELECT
     select HAVE_GPIO_HARD_PWM
     select HAVE_GPIO_I2C
 
+config USE_LIBGPIOD
+    bool "Use libgpiod for GPIO support"
+    default n
+    select HAVE_GPIO_BITBANGING
+    select HAVE_GPIO
+
 config BOARD_DIRECTORY
     string
     default "linux"
diff --git a/src/linux/Makefile b/src/linux/Makefile
index 5cc9c69a..f65bbafe 100644
--- a/src/linux/Makefile
+++ b/src/linux/Makefile
@@ -4,9 +4,11 @@ dirs-y += src/linux src/generic
 
 src-y += linux/main.c linux/timer.c linux/console.c linux/watchdog.c
 src-y += linux/pca9685.c linux/spidev.c linux/analog.c linux/hard_pwm.c
-src-y += linux/i2c.c generic/crc16_ccitt.c generic/alloc.c
+src-y += linux/i2c.c linux/gpio.c generic/crc16_ccitt.c generic/alloc.c
 
-CFLAGS_klipper.elf += -lutil
+libs-$(CONFIG_USE_LIBGPIOD) += -lgpiod
+
+CFLAGS_klipper.elf += -lutil $(libs-y)
 
 flash: $(OUT)klipper.elf
 	@echo "  Flashing"
diff --git a/src/linux/analog.c b/src/linux/analog.c
index 2ce085a8..aa8fb701 100644
--- a/src/linux/analog.c
+++ b/src/linux/analog.c
@@ -15,15 +15,17 @@
 
 DECL_CONSTANT("ADC_MAX", 4095); // Assume 12bit adc
 
-DECL_ENUMERATION_RANGE("pin", "analog0", 0, 8);
+#define ANALOG_START (1<<8)
+
+DECL_ENUMERATION_RANGE("pin", "analog0", ANALOG_START, 8);
 
 #define IIO_PATH "/sys/bus/iio/devices/iio:device0/in_voltage%d_raw"
 
 struct gpio_adc
-gpio_adc_setup(uint8_t pin)
+gpio_adc_setup(uint32_t pin)
 {
     char fname[256];
-    snprintf(fname, sizeof(fname), IIO_PATH, pin);
+    snprintf(fname, sizeof(fname), IIO_PATH, pin-ANALOG_START);
 
     int fd = open(fname, O_RDONLY|O_CLOEXEC);
     if (fd < 0) {
diff --git a/src/linux/gpio.c b/src/linux/gpio.c
new file mode 100644
index 00000000..38c745ee
--- /dev/null
+++ b/src/linux/gpio.c
@@ -0,0 +1,153 @@
+// Very basic support via a Linux gpiod device
+//
+// Copyright (C) 2017-2018  Kevin O'Connor <kevin@koconnor.net>
+//
+// This file may be distributed under the terms of the GNU GPLv3 license.
+#include "autoconf.h"
+#include "gpio.h"
+#include "command.h" // shutdown
+#include "sched.h" // shutdown
+
+#if CONFIG_USE_LIBGPIOD
+#include <fcntl.h> // open
+#include <stdio.h> // snprintf
+#include <string.h> // memset
+#include <stdlib.h> // atexit
+
+#include "internal.h" // report_errno
+#include <gpiod.h>
+
+
+static struct gpiod_chip * chip = NULL;
+#define CHIP_NAME "gpiochip0"
+
+DECL_ENUMERATION_RANGE("pin", "P0", 0, 40);
+
+static void
+close_chip(void)
+{
+    gpiod_chip_close(chip);
+}
+
+static struct gpiod_chip*
+get_chip(void) {
+    if (chip == NULL) {
+        chip = gpiod_chip_open_by_name(CHIP_NAME);
+        if (chip == NULL) {
+            report_errno("gpiod_chip_open_by_name",-1);
+            shutdown("Unable to open GPIO chip device");
+        }
+        atexit(&close_chip);
+    }
+    return chip;
+}
+
+// Dummy versions of gpio_out functions
+struct gpio_out
+gpio_out_setup(uint32_t pin, uint8_t val)
+{
+    int ret;
+    struct gpiod_line* line = gpiod_chip_get_line(get_chip(), pin);
+    if (line == NULL) {
+        report_errno("gpiod_chip_get_line",-1);
+        shutdown("Unable to open GPIO chip line");
+    }
+    if (gpiod_line_is_requested(line)) {
+        gpiod_line_release(line);
+    }
+    if ((ret = gpiod_line_request_output(line,"klipper",val)) != 0) {
+        report_errno("gpiod_line_request_output",ret);
+        shutdown("Unable to request GPIO line output");
+    }
+    gpiod_line_set_value(line,val?1:0);
+    struct gpio_out g = { .line = line };
+    return g;
+}
+
+void
+gpio_out_reset(struct gpio_out g, uint8_t val)
+{
+    int ret;
+    if (gpiod_line_is_requested(g.line)) {
+        gpiod_line_release(g.line);
+    }
+    if ((ret = gpiod_line_request_output(g.line,"klipper",val)) != 0) {
+        report_errno("gpiod_line_request_output",ret);
+        shutdown("Unable to reset GPIO line output");
+    }
+}
+
+void
+gpio_out_write(struct gpio_out g, uint8_t val)
+{
+    gpiod_line_set_value(g.line,val?1:0);
+}
+
+void
+gpio_out_toggle(struct gpio_out g)
+{
+    gpiod_line_set_value(g.line,!gpiod_line_get_value(g.line));
+}
+
+void
+gpio_out_toggle_noirq(struct gpio_out g)
+{
+    gpio_out_toggle(g);
+}
+
+struct gpio_in
+gpio_in_setup(uint32_t pin, int8_t pull_up)
+{
+    int ret;
+    struct gpiod_line * line = gpiod_chip_get_line(get_chip(), pin);
+    if (line == NULL) {
+        report_errno("gpiod_chip_get_line",-1);
+        shutdown("Unable to open GPIO chip line");
+    }
+    if (gpiod_line_is_requested(line)) {
+        gpiod_line_release(line);
+    }
+    if ((ret = gpiod_line_request_input_flags(line,"klipper",0)) != 0) {
+        report_errno("gpiod_line_request_input_flags",ret);
+        shutdown("Unable to request GPIO line input");
+    }
+    struct gpio_in g = { .line = line };
+    return g;
+}
+
+void
+gpio_in_reset(struct gpio_in g, int8_t pull_up)
+{
+    int ret;
+    if (gpiod_line_is_requested(g.line)) {
+        gpiod_line_release(g.line);
+    }
+    if ((ret = gpiod_line_request_input_flags(g.line,"klipper",0)) != 0) {
+        report_errno("gpiod_line_request_input_flags",ret);
+        shutdown("Unable to request GPIO line input");
+    }
+}
+
+uint8_t
+gpio_in_read(struct gpio_in g)
+{
+    return gpiod_line_get_value(g.line);
+}
+
+#else
+
+
+// Dummy versions of gpio_out functions
+struct gpio_out
+gpio_out_setup(uint8_t pin, uint8_t val)
+{
+    shutdown("gpio_out_setup not supported");
+}
+
+void
+gpio_out_write(struct gpio_out g, uint8_t val)
+{
+}
+
+
+#endif
diff --git a/src/linux/gpio.h b/src/linux/gpio.h
index 32e76bf5..f09a73c7 100644
--- a/src/linux/gpio.h
+++ b/src/linux/gpio.h
@@ -2,19 +2,35 @@
 #define __LINUX_GPIO_H
 
 #include <stdint.h> // uint8_t
-
+#include "autoconf.h"
+#if CONFIG_USE_LIBGPIOD
 struct gpio_out {
-    uint32_t pin;
+    struct gpiod_line* line;
 };
-struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
+struct gpio_out gpio_out_setup(uint32_t pin, uint8_t val);
+void gpio_out_reset(struct gpio_out g, uint8_t val);
 void gpio_out_toggle_noirq(struct gpio_out g);
 void gpio_out_toggle(struct gpio_out g);
 void gpio_out_write(struct gpio_out g, uint8_t val);
 
+struct gpio_in {
+    struct gpiod_line* line;
+};
+struct gpio_in gpio_in_setup(uint32_t pin, int8_t pull_up);
+void gpio_in_reset(struct gpio_in g, int8_t pull_up);
+uint8_t gpio_in_read(struct gpio_in g);
+#else
+struct gpio_out {
+    int dummy;
+};
+struct gpio_out gpio_out_setup(uint8_t pin, uint8_t val);
+void gpio_out_write(struct gpio_out g, uint8_t val);
+#endif
+
 struct gpio_adc {
     int fd;
 };
-struct gpio_adc gpio_adc_setup(uint8_t pin);
+struct gpio_adc gpio_adc_setup(uint32_t pin);
 uint32_t gpio_adc_sample(struct gpio_adc g);
 uint16_t gpio_adc_read(struct gpio_adc g);
 void gpio_adc_cancel_sample(struct gpio_adc g);
@@ -32,7 +48,7 @@ struct gpio_pwm {
     int fd;
     uint32_t period;
 };
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint16_t val);
+struct gpio_pwm gpio_pwm_setup(uint32_t pin, uint32_t cycle_time, uint16_t val);
 void gpio_pwm_write(struct gpio_pwm g, uint16_t val);
 
 struct i2c_config {
diff --git a/src/linux/hard_pwm.c b/src/linux/hard_pwm.c
index 25bfb2e7..00b39500 100644
--- a/src/linux/hard_pwm.c
+++ b/src/linux/hard_pwm.c
@@ -31,7 +31,7 @@ DECL_ENUMERATION_RANGE("pin", "pwmchip3/pwm0", HARD_PWM(3, 0), 256);
 
 #define PWM_PATH "/sys/class/pwm/pwmchip%u/pwm%u/%s"
 
-struct gpio_pwm gpio_pwm_setup(uint8_t pin, uint32_t cycle_time, uint16_t val)
+struct gpio_pwm gpio_pwm_setup(uint32_t pin, uint32_t cycle_time, uint16_t val)
 {
     char filename[256];
     char scratch[16];
diff --git a/src/linux/spidev.c b/src/linux/spidev.c
index 764541e3..166db395 100644
--- a/src/linux/spidev.c
+++ b/src/linux/spidev.c
@@ -107,15 +107,3 @@ spi_transfer(struct spi_config config, uint8_t receive_data
         }
     }
 }
-
-// Dummy versions of gpio_out functions
-struct gpio_out
-gpio_out_setup(uint8_t pin, uint8_t val)
-{
-    shutdown("gpio_out_setup not supported");
-}
-
-void
-gpio_out_write(struct gpio_out g, uint8_t val)
-{
-}
-- 
2.24.2 (Apple Git-127)

